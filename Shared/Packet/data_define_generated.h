// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATADEFINE_FLATPACKET_H_
#define FLATBUFFERS_GENERATED_DATADEFINE_FLATPACKET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace FlatPacket {

struct item;
struct itemBuilder;

enum PacketType : int8_t {
  PacketType_None = 0,
  PacketType_Sign_In = 1,
  PacketType_Sign_Up = 2,
  PacketType_User_Information = 3,
  PacketType_Attendance_Sheets = 4,
  PacketType_Attendance_Check = 5,
  PacketType_MailsInfo = 6,
  PacketType_MailConfirm = 7,
  PacketType_MailReceive = 8,
  PacketType_ReceivedRewards = 9,
  PacketType_FindSession = 10,
  PacketType_CreateSession = 11,
  PacketType_JoinSession = 12,
  PacketType_SessionRequest = 13,
  PacketType_GameStart = 14,
  PacketType_DB_Sign_In = 15,
  PacketType_DB_Sign_Up = 16,
  PacketType_DB_User_Information = 17,
  PacketType_DB_Attendance_Sheets = 18,
  PacketType_DB_Attendance_Check = 19,
  PacketType_DB_MailConfirm = 20,
  PacketType_DB_MailReceive = 21,
  PacketType_DB_CheckExpiredMails = 22,
  PacketType_DB_MailsInfo = 23,
  PacketType_Error = 24,
  PacketType_Disconnect = 25,
  PacketType_JsonDownloadStartPacket = 26,
  PacketType_JsonDownloadingPacket = 27,
  PacketType_JsonDownloadEndPacket = 28,
  PacketType_MIN = PacketType_None,
  PacketType_MAX = PacketType_JsonDownloadEndPacket
};

inline const PacketType (&EnumValuesPacketType())[29] {
  static const PacketType values[] = {
    PacketType_None,
    PacketType_Sign_In,
    PacketType_Sign_Up,
    PacketType_User_Information,
    PacketType_Attendance_Sheets,
    PacketType_Attendance_Check,
    PacketType_MailsInfo,
    PacketType_MailConfirm,
    PacketType_MailReceive,
    PacketType_ReceivedRewards,
    PacketType_FindSession,
    PacketType_CreateSession,
    PacketType_JoinSession,
    PacketType_SessionRequest,
    PacketType_GameStart,
    PacketType_DB_Sign_In,
    PacketType_DB_Sign_Up,
    PacketType_DB_User_Information,
    PacketType_DB_Attendance_Sheets,
    PacketType_DB_Attendance_Check,
    PacketType_DB_MailConfirm,
    PacketType_DB_MailReceive,
    PacketType_DB_CheckExpiredMails,
    PacketType_DB_MailsInfo,
    PacketType_Error,
    PacketType_Disconnect,
    PacketType_JsonDownloadStartPacket,
    PacketType_JsonDownloadingPacket,
    PacketType_JsonDownloadEndPacket
  };
  return values;
}

inline const char * const *EnumNamesPacketType() {
  static const char * const names[30] = {
    "None",
    "Sign_In",
    "Sign_Up",
    "User_Information",
    "Attendance_Sheets",
    "Attendance_Check",
    "MailsInfo",
    "MailConfirm",
    "MailReceive",
    "ReceivedRewards",
    "FindSession",
    "CreateSession",
    "JoinSession",
    "SessionRequest",
    "GameStart",
    "DB_Sign_In",
    "DB_Sign_Up",
    "DB_User_Information",
    "DB_Attendance_Sheets",
    "DB_Attendance_Check",
    "DB_MailConfirm",
    "DB_MailReceive",
    "DB_CheckExpiredMails",
    "DB_MailsInfo",
    "Error",
    "Disconnect",
    "JsonDownloadStartPacket",
    "JsonDownloadingPacket",
    "JsonDownloadEndPacket",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketType(PacketType e) {
  if (::flatbuffers::IsOutRange(e, PacketType_None, PacketType_JsonDownloadEndPacket)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketType()[index];
}

enum RequestMessageType : int8_t {
  RequestMessageType_None = 0,
  RequestMessageType_Succeeded = 1,
  RequestMessageType_Failed = 2,
  RequestMessageType_MIN = RequestMessageType_None,
  RequestMessageType_MAX = RequestMessageType_Failed
};

inline const RequestMessageType (&EnumValuesRequestMessageType())[3] {
  static const RequestMessageType values[] = {
    RequestMessageType_None,
    RequestMessageType_Succeeded,
    RequestMessageType_Failed
  };
  return values;
}

inline const char * const *EnumNamesRequestMessageType() {
  static const char * const names[4] = {
    "None",
    "Succeeded",
    "Failed",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestMessageType(RequestMessageType e) {
  if (::flatbuffers::IsOutRange(e, RequestMessageType_None, RequestMessageType_Failed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestMessageType()[index];
}

struct item FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef itemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_ID = 4,
    VT_ITEM_COUNT = 6
  };
  int32_t item_id() const {
    return GetField<int32_t>(VT_ITEM_ID, 0);
  }
  int32_t item_count() const {
    return GetField<int32_t>(VT_ITEM_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEM_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct itemBuilder {
  typedef item Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item_id(int32_t item_id) {
    fbb_.AddElement<int32_t>(item::VT_ITEM_ID, item_id, 0);
  }
  void add_item_count(int32_t item_count) {
    fbb_.AddElement<int32_t>(item::VT_ITEM_COUNT, item_count, 0);
  }
  explicit itemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<item>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<item> Createitem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item_id = 0,
    int32_t item_count = 0) {
  itemBuilder builder_(_fbb);
  builder_.add_item_count(item_count);
  builder_.add_item_id(item_id);
  return builder_.Finish();
}

inline const FlatPacket::item *Getitem(const void *buf) {
  return ::flatbuffers::GetRoot<FlatPacket::item>(buf);
}

inline const FlatPacket::item *GetSizePrefixeditem(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<FlatPacket::item>(buf);
}

inline bool VerifyitemBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FlatPacket::item>(nullptr);
}

inline bool VerifySizePrefixeditemBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FlatPacket::item>(nullptr);
}

inline void FinishitemBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FlatPacket::item> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixeditemBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FlatPacket::item> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FlatPacket

#endif  // FLATBUFFERS_GENERATED_DATADEFINE_FLATPACKET_H_
